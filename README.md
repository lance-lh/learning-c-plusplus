# learning C++

## Contents
- [NewProject](#newproject)
- [Youtube](#youtube)
    - [Date: 2019-1-7](#2019-1-7)
        - [function pointer](#function-pointer)
        - [lambda](#lambda)
        - [not using namespace std](#not-using-namespace-std)
        - [namespace](#namespace)
        - [threads](#threads)
    - [Date: 2019-1-6](#2019-1-6)
        - [auto](#auto)
        - [static array](#static-array)
    - [Date: 2019-1-5](#2019-1-5)
        - [macros](#macros)
    - [Date: 2019-1-4](#2019-1-4)
        - [stack vs heap](#stack-vs-heap)
    - [Date: 2018-12-29](#2018-12-29)
        - [multiple projects](#multiple-projects)
        - [Templates](#templates)
    - [Date: 2018-12-28](#2018-12-28)
        - [dynamic linking](#dynamic-linking)
    - [Date: 2018-12-27](#2018-12-27)
        - [static linking](#static-linking)
    - [Date: 2018-12-26](#2018-12-26)
        - [vector optimization](#vector-optimization)
    - [Date: 2018-12-25](#2018-12-25)
        - [smart pointers](#smart-pointers)
        - [copying and copy constructor](#copying-and-copy-constructor)
        - [array operator](#array-operator)
        - [dynamic arrays](#dynamic-arrays)
    - [Date: 2018-12-24](#2018-12-24)
        - [Operators and operator overloading](#Operators-and-operator-overloading)
        - [this](#this)
        - [object lifetime](#object-lifetime)
    - [Date: 2018-12-23](#2018-12-23)
        - [Create objects](#create-objects)
        - [new and delete](#new-and-delete)
        - [implicit conversion and explicit](#implicit-conversion-and-explicit)
    - [Date: 2018-12-22](#2018-12-22)
        - [ternary operator](#ternary-operator)
    - [Date: 2018-12-21](#2018-12-21)
        - [mutable](#mutable)
        - [constructor initializer list](#constructor-initializer-list)
    - [Date: 2018-12-20](#2018-12-20)
        - [String literals](#string_literals)
        - [Const](#const)
    - [Date: 2018-12-19](#2018-12-19)
        - [Generate course list](#generate-course-list)
    - [Date: 2018-12-18](#2018-12-18)
        - [Strings](#strings)
    - [Date: 2018-12-17](#2018-12-17)
        - [Array](#array)
        - [Visibility](#visibility)
        - [Pure virtual func2](#pure_virtual_func2)
        - [SRO](#sro)
        - [Pure virtual func](#pure_virtual_func)
        - [Virtual_func](#virtual_func)
        - [Inheritance](#inheritance)
    - [Date: 2018-12-16](#2018-12-16)
        - [Constructor](#constructor)
        - [Log1](#log1)
        - [Enum](#enum)
    - [Date: 2018-12-15](#2018-12-15)
    - [Date: 2018-12-14](#2018-12-14)
    - [Date: 2018-12-13](#2018-12-13)
    - [Date: 2018-12-12](#2018-12-12)

## NewProject 

It provides a recommended `VS` *Directory Structure* as follows:

![](https://i.loli.net/2018/12/17/5c17a606d7d18.png)

## Youtube  
<details>
<summary>course list</summary>  

- [x] "Welcome to C++" 
- [x] "How to Setup C++ on Windows" 
- [ ] "How to Setup C++ on Mac" 
- [ ] "How to Setup C++ on Linux" 
- [x] "How C++ Works" 
- [x] "How the C++ Compiler Works" 
- [x] "How the C++ Linker Works" 
- [x] "Variables in C++" 
- [x] "Functions in C++" 
- [x] "C++ Header Files" 
- [x] "How to DEBUG C++ in VISUAL STUDIO" 
- [x] "CONDITIONS and BRANCHES in C++ (if statements)" 
- [x] "BEST Visual Studio Setup for C++ Projects!" 
- [x] "Loops in C++ (for loops, while loops)" 
- [x] "Control Flow in C++ (continue, break, return)" 
- [x] "POINTERS in C++" 
- [x] "REFERENCES in C++" 
- [x] "CLASSES in C++" 
- [x] "CLASSES vs STRUCTS in C++" 
- [x] "How to Write a C++ Class" 
- [x] "Static in C++" 
- [x] "Static for Classes and Structs in C++" 
- [x] "Local Static in C++" 
- [x] "ENUMS in C++" 
- [x] "Constructors in C++" 
- [x] "Destructors in C++" 
- [x] "Inheritance in C++" 
- [x] "Virtual Functions in C++" 
- [x] "Interfaces in C++ (Pure Virtual Functions)" 
- [x] "Visibility in C++" 
- [x] "Arrays in C++" 
- [x] "How Strings Work in C++ (and how to use them)" 
- [x] "String Literals in C++" 
- [x] "CONST in C++" 
- [x] "The Mutable Keyword in C++" 
- [x] "Member Initializer Lists in C++ (Constructor Initializer List)" 
- [x] "Ternary Operators in C++ (Conditional Assignment)" 
- [x] "How to CREATE/INSTANTIATE OBJECTS in C++" 
- [x] "The NEW Keyword in C++" 
- [x] "Implicit Conversion and the Explicit Keyword in C++" 
- [x] "OPERATORS and OPERATOR OVERLOADING in C++" 
- [x] "The &quot;this&quot; keyword in C++" 
- [x] "Object Lifetime in C++ (Stack/Scope Lifetimes)" 
- [x] "SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)" 
- [x] "Copying and Copy Constructors in C++" 
- [x] "The Arrow Operator in C++" 
- [x] "Dynamic Arrays in C++ (std::vector)" 
- [x] "Optimizing the usage of std::vector in C++" 
- [x] "Using Libraries in C++ (Static Linking)" 
- [x] "Using Dynamic Libraries in C++" 
- [x] "Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)" 
- [ ] "How to Deal with Multiple Return Values in C++" 
- [x] "Templates in C++" 
- [x] "Stack vs Heap Memory in C++" 
- [x] "Macros in C++" 
- [x] "The &quot;auto&quot; keyword in C++" 
- [x] "Static Arrays in C++ (std::array)" 
- [x] "Function Pointers in C++" 
- [x] "Lambdas in C++" 
- [x] "Why I don&#39;t &quot;using namespace std&quot;" 
- [x] "Namespaces in C++" 
- [x] "Threads in C++" 
- [ ] "Timing in C++" 
- [ ] "Multidimensional Arrays in C++ (2D arrays)" 
- [ ] "Sorting in C++" 
- [ ] "Type Punning in C++" 
- [ ] "Unions in C++" 
- [ ] "Virtual Destructors in C++" 
- [ ] "Casting in C++" 
- [ ] "Conditional and Action Breakpoints in C++" 
- [ ] "Safety in modern C++ and how to teach it" 
- [ ] "Precompiled Headers in C++"   

</details> 

### 2019-1-7  
#### function pointer  
```c++
void HelloWorld(int a)
{
	std::cout << "Hello World! Value: " << a << std::endl;
}

int main()
{
    typedef void(*HelloWorldFunction)(int);  // define a type
    HelloWorldFunction function = HelloWorld;
    function(8);
    function(9);
    function(6);
}
```

```c++
void PrintValue(int value)
{
	std::cout << "Value: " << value << std::endl;
}

void ForEach(const std::vector<int>& values, void(*func)(int))
{
	for (int value : values)
		func(value);
}

int main()
{
	std::vector<int> values = { 1, 5, 4, 2, 3 };
	ForEach(values, PrintValue);
	ForEach(values, [](int value) {std::cout << "Value: " << value << std::endl; });   // lambdas

	std::cin.get();
}
```

#### lambda  
> Lambda expressions: an unnamed function object capable of capturing variables in scope. [link](https://en.cppreference.com/w/cpp/language/lambda)  

```c++
[capture list] (params list) mutable exception-> return type { function body }
```

[C++ 11 Lambda表达式](https://www.cnblogs.com/DswCnblog/p/5629165.html)

| 序号 | 格式                                                         |
| ---- | ------------------------------------------------------------ |
| 1    | `[capture list] (params list) -> return type {function body}` |
| 2    | `[capture list] (params list) {function body}`               |
| 3    | `[capture list] {function body}`                             |

| 捕获形式    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| []          | 不捕获任何外部变量                                           |
| [变量名, …] | 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符） |
| [this]      | 以值的形式捕获this指针                                       |
| [=]         | 以值的形式捕获所有外部变量                                   |
| [&]         | 以引用形式捕获所有外部变量                                   |
| [=, &x]     | 变量x以引用形式捕获，其余变量以传值形式捕获                  |
| [&, x]      | 变量x以值的形式捕获，其余变量以引用形式捕获                  |

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<functional>

void ForEach(const std::vector<int>& values, const std::function<void(int)>& func)
{
	for (int value : values)
		func(value);
}

int main()
{
	std::vector<int> values = { 1, 5, 4, 2, 3 };
	auto it = std::find_if(values.begin(), values.end(), [](int value) {return value > 3; });
	std::cout << *it << std::endl;

	int a = 5;

	auto lambda = [=](int value) {std::cout << "Value: " << a << std::endl; };
	ForEach(values, lambda);   

	std::cin.get();
}
```

#### not using namespace std  
It is Cherno's personal opinion. It might be confusing if you wanna distinguish which function belongs to std library. And there is one case that you might name your function  similar to std library function name. So, try to use std `namespace` less, small scope and remember never put `namespace` into header file because it is tough to debug your code.  

```c++
#include<iostream>
#include<string>

namespace apple    // it needs implicit conversion
{
	void print(const std::string& text)
	{
		std::cout << text << std::endl;
	}
}

namespace orrange   // if both exist, this one is a better choice
{
	void print(const char* text)
	{
		std::string temp = text;
		std::reverse(temp.begin(), temp.end());
		std::cout << temp << std::endl;
	}
}

using namespace apple;
using namespace orrange;

int main()
{
	print("Hello!");  // "Hello" is a const char array, actually not string
	std::cin.get();
}
```

#### namespace  
> Namespaces provide a method for **preventing name conflicts** in large projects.
>
> Symbols declared inside a namespace block are placed in a named scope that prevents them from being mistaken for identically-named symbols in other scopes.
>
> Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in the named scope.  
>

* More examples can be found [here](https://www.geeksforgeeks.org/namespace-in-c/).  

#### threads  
> The class thread represents a single thread of execution. Threads allow multiple functions to execute concurrently.
> 
> Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a constructor argument. The return value of the top-level function is ignored and if it terminates by throwing an exception, std::terminate is called. The top-level function may communicate its return value or an exception to the caller via std::promise or by modifying shared variables (which may require synchronization, see std::mutex and std::atomic)
> 
> std::thread objects may also be in the state that does not represent any thread (after default construction, move from, detach, or join), and a thread of execution may be not associated with any thread objects (after detach).
> 
> No two std::thread objects may represent the same thread of execution; std::thread is not *CopyConstructible* or *CopyAssignable*, although it is *MoveConstructible* and *MoveAssignable*. [link](https://en.cppreference.com/w/cpp/thread/thread)  

```c++
#include<iostream>
#include<thread>

static bool s_Finished = false;

void DoWork()
{
	using namespace std::literals::chrono_literals;

	std::cout << "Started thread id=" << std::this_thread::get_id() << std::endl;

	while (!s_Finished)  // s_Finished = false, keep running
	{
		std::cout << "Working...\n";
		std::this_thread::sleep_for(1s);
	}
}

int main()
{
	std::thread worker(DoWork);

	std::cin.get(); // block this thread until we press ENTER
	s_Finished = true;  // change status, stop working

	worker.join();  // we don't do cin.get() until that thread has actually finished its execution
	std::cout << "Finished." << std::endl;
	std::cout << "Started thread id=" << std::this_thread::get_id() << std::endl;

	std::cin.get();
}
```

* `join` waits for a thread to finish its execution  

***
### 2019-1-6  
#### auto  
> use auto if the data type is too long  

*for example*,  
`for (std::vector<std::string>::iterator it = strings.begin();it != strings.end(); it++)` vs  `for (auto it = strings.begin(); it != strings.end(); it++)`  

> *For variables*, specifies that the type of the variable that is **being declared** will be automatically deduced from its initializer. 
>
> *For functions*, specifies that the **return type** is a trailing return type or will be deduced from its return statements (since C++14) 
>
> *For non-type template parameters*, specifies that the type will be deduced from the **argument** (since C++17). [link](https://en.cppreference.com/w/cpp/language/auto)

#### static array  
> when you create a C++ standard array, it provides you a fixed size, pre-defined data type array, that's what we called static.
> 
> standard array is stored on the stack, while vector is stored on the heap, because vector is a changeable array, it needs heap allocation
> 
> standard array has boundary check for you optionally, it's up to debug or release mode you choose.  

```c++
int main()
{
	std::array<int, 5> data; //&data, it is a class, so we can keep track of its size

	// pay attention that this size is not the real memory size it occupies
	int arraysize = data.size();
	std::cout << arraysize << std::endl;

	data[0] = 2;
	data[4] = 1;

	std::cin.get();
}
```

* [Static array vs. dynamic array in C++](https://stackoverflow.com/questions/2672085/static-array-vs-dynamic-array-in-c)  

Here are two awesome answers about this question, I think they are easy-understood.  
> Local arrays are created on the stack, and have automatic storage duration -- you don't need to manually manage memory, but they get destroyed when the function they're in ends. They necessarily have a fixed size:
>
> `int foo[10];`
>
> Arrays created with operator new[] have dynamic storage duration and are stored on the heap (technically the "free store"). They can have any size, but you need to allocate and free them yourself since they're not part of the stack frame:
>
> ```c++
> int* foo = new int[10];
> delete[] foo;
> ```

> I think the semantics being used in your class are confusing. What's probably meant by 'static' is simply "constant size", and what's probably meant by "dynamic" is "variable size". In that case then, a constant size array might look like this:
>
> `int x[10];`
> and a "dynamic" one would just be any kind of structure that allows for the underlying storage to be increased or decreased at runtime. Most of the time, the std::vector class from the C++ standard library will suffice. Use it like this:
>
> `std::vector<int> x(10);` // this starts with 10 elements, but the vector can be resized.
>
> `std::vector` has `operator[]` defined, so you can use it with the same semantics as an array.  

***
### 2019-1-5  
#### macros  
> simply to say, macro is just to find/replace  

```c++
#define WAIT std::cin.get()

#define LOG(x) std::cout << x << std::endl;

int main()
{
	LOG("hello");
	WAIT;
}
```

`#define WAIT std::cin.get()` it is not suggested to use preprocessor this way, because if the code is in other file, it may be confusing to know what it exactly means.  

> Visual Studio projects have separate release and debug configurations for your program. You build the debug version for debugging and the release version for the final release distribution.
>
> In debug configuration, your program compiles with full symbolic debug information and no optimization. Optimization complicates debugging, because the relationship between source code and generated instructions is more complex.
>
> The release configuration of your program has no symbolic debug information and is fully optimized. Debug information can be generated in .pdb files, depending on the compiler options that are used. Creating .pdb files can be useful if you later have to debug your release version.
> [link here](https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-configurations?view=vs-2017#BKMK_symbols_release)   

> Well, it depends on what language you are using, but in general they are 2 separate configurations, each with its own settings. By default, Debug includes debug information in the compiled files (allowing easy debugging) while Release usually has optimizations enabled.
>
> As far as conditional compilation goes, they each define different symbols that can be checked in your program, but they are language-specific macros.
> 
> In general, though, you'll use "Debug" when you want your project to be built with the optimiser turned off, and when you want full debugging/symbol information included in your build (in the .PDB file, usually). You'll use "Release" when you want the optimiser turned on, and when you don't want full debugging information included.
> [link here](https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio)  



***
### 2019-1-4  
#### stack vs heap  
> to be clear, each program/process on our computer has its own stack/heap
>
> each thread will create its own stack when it gets created, whereas the heap is shared amongst all threads

* allocating memory on heap is a bunch of whole thing, whereas allocating memory on the stack is like one CPU instruction  
- [ ] when to use stack or heap  
* `new` is actually call function `malloc`  


```c++
#include<iostream>
#include<string>

struct Vector3
{
	float x, y, z;

	Vector3()
		: x(10), y(11), z(12) {}
};

int main()
{
	{	// stack memory allocation
		int value = 5; // &value, Memory address: 0x0093FC38 (9698360), value: 05 00 00 00  
		int array[5]; // array is actually a pointer, Memory address: 0x0093FC1C (9698332), value: 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00 
		array[0] = 1;
		array[1] = 2;
		array[2] = 3;
		array[3] = 4;
		array[4] = 5;
		Vector3 vector;  // &vector, Memory address: 0x0093FC08, 00 00 20 41 00 00 30 41 00 00 40 41 
	}  // for stack variable, if variable is outside the current scope, it gets freed
	//  00 00 20 41 00 00 30 41 00 00 40 41 cc cc cc cc cc cc cc cc 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00 cc cc cc cc cc cc cc cc 05 00 00 00

	// heap memory allocation
	int* hvalue = new int;
	*hvalue = 5;
	int* harray = new int[5];   // 0x00192E40
	harray[0] = 1;  // 0x0018CB0C
	harray[1] = 2;
	harray[2] = 3;
	harray[3] = 4;
	harray[4] = 5;
	Vector3* hvector = new Vector3();  // 0x00192274

	// manully free heap memory
	delete hvalue;
	delete[] harray;
	delete hvector;

	std::cin.get();
}
```

* we can see that stack memory pointer moves from higher address to lower address  
* a stack allocation is extremely fast, it's literally like one CPU instruction. All we do is we move the stack pointer and then we return the address of that stack pointer.  
* use `new` keyword to allocate heap memory  
* use `delete` to manually free heap memory  
* heap memory address grow from lower address to higher address  

***
### 2018-12-29  
#### multiple projects  
Here, we have two projects called **Game** and **Enigne**. **Game** is the main project, so we set its **Configuration Type** as **Application (.exe)**, and **Engine** as **Static library (.lib)**. That's the only difference.  
* include another project's header file  
One way is to use *relative path*, such as `#include"../../Engine/src/Engine.h"`  
The other way is use *absolute path*. To achieve this, we can make some property change to *Microsoft Visual Studio*
For example, we set **Additional Include Directories** as **$(SolutionDir)Engine\src**  

Note that: In my implementation, **$(SolutionDir)** means the directory where solution file (.sln) locates. And the **$(SolutionDir)** itself has a backslash symbol (\\) at the end of path. 

Then we can directly use existing absolute path setting as `#include"Engine.h"`  

Now we fix the compilation problem, but now the linking still has some issues. We first build **Engine** project, it generates **Engine.lib** file because we already set its property as **Static library (.lib)**. Then we should right click the **Game** project and add reference into it. Then the error message is gone.  

If we clean the solution, and build Game. The result will look like this : first build Engine and then build Game. Because engine is actually required for game to work since we've added it as a reference and since we are linking against it.   

#### Templates  
> template does not exist until we call it
>
> the compiler writes code for you based on the rules that you've given it and based on the usage of that functional class or anything like that

Here is a specific explanation of [templates](http://www.cplusplus.com/doc/oldtutorial/templates/).

***
### 2018-12-28  
* What is the difference between `#include <filename>` and `#include “filename”`?  
> In practice, the difference is in **the location where the preprocessor searches for the included file**.
>
> For `#include <filename> `the preprocessor searches in an implementation dependent manner, normally in search directories pre-designated by the compiler/IDE. This method is normally used to include **standard library header files**.
>
> For `#include "filename"` the preprocessor searches first in the same directory as the file containing the directive, and then follows the search path used for the `#include <filename>` form. This method is normally used to **include programmer-defined header files**.
>
> A more complete description is available in the GCC [documentation on search paths](https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html).

#### dynamic linking  
In my opinion, **dynamic linking** means your executable is separated from some **.dll** (dynamic linking libraries). On the contrary, **static linking** means when you compile and link your code, some necessary libraries are incorporated into your final executable file, so it doesn't need some extra libraries support since it already includes all necessary stuffs. In other word, because static linking relates with some compilation and linking procedure, it actually has to consider some optimizations so that the final executable will be more efficient.  
* Dynamic linking vs Static linking [link](http://cs-fundamentals.com/tech-interview/c/difference-between-static-and-dynamic-linking.php)  
> The program we write might make use of other programs (which is usually the case), or libraries of programs. These other programs or libraries must be brought together with the program we write in order to execute it.
>
> Linking is the process of bringing external programs together required by the one we write for its successful execution. Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Here we will discuss the difference between them. Read full article on static and dynamic linking for more details. 
>
> Linking can be performed at both compile time, when the source code is translated into machine code; and load time, when the program is loaded into memory by the loader, and even at run time, by application programs. And, it is performed by programs called linkers. Linkers are also called link editors. Linking is performed as the last step in compiling a program. 
>
> After linking, for execution the combined program must be moved into memory. In doing so, there must be addresses assigned to the data and instructions for execution purposes. The above process can be summarized as program life cycle (**write -> compile -> link -> load -> execute**).



| Static Linking                                               | Dynamic Linking                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Static linking is the process of copying all library modules used in the program into the final executable image. This is performed by the linker and it is done as the last step of the compilation process. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. When the program is loaded, the operating system places into memory a single file that contains the executable code and data. This statically linked file includes both the calling program and the called program. | In dynamic linking the names of the external libraries (shared libraries) are placed in the final executable file while the actual linking takes place at run time when both executable file and libraries are placed in the memory. Dynamic linking lets several programs use a single copy of an executable module. |
| Static linking is performed by programs called linkers as the last step in compiling a program. Linkers are also called link editors. | Dynamic linking is performed at run time by the operating system. |
| Statically linked files are significantly larger in size because external programs are built into the executable files. | In dynamic linking only one copy of shared library is kept in memory. This significantly reduces the size of executable programs, thereby saving memory and disk space. |
| In static linking if any of the external programs has changed then they have to be recompiled and re-linked again else the changes won't reflect in existing executable file. | In dynamic linking this is not the case and individual shared modules can be updated and recompiled. This is one of the greatest advantages dynamic linking offers. |
| Statically linked program takes constant load time every time it is loaded into the memory for execution. | In dynamic linking load time might be reduced if the shared library code is already present in memory. |
| Programs that use statically-linked libraries are usually faster than those that use shared libraries. | Programs that use shared libraries are usually slower than those that use statically-linked libraries. |
| In statically-linked programs, all code is contained in a single executable module. Therefore, they never run into compatibility issues. | Dynamically linked programs are dependent on having a compatible library. If a library is changed (for example, a new compiler release may change a library), applications might have to be reworked to be made compatible with the new version of the library. If a library is removed from the system, programs using that library will no longer work. |

***
### 2018-12-27  
#### static linking  

1. Download **GLFW** [here](https://www.glfw.org/download.html) , choose *32-bit  Windows binaries*.  
2. Unzip **glfw-3.2.1.bin.WIN32.zip** file
3. Copy **include** and **lib-vc2015** two folders to a new folder called **GLFW**
4. Copy the entire folder **GLFW** to a new folder called **Dependencies** 
5. Copy the **Dependencies** folder to project root directory
6. So, the final project folder looks like this: 

   ![](https://i.loli.net/2018/12/28/5c258f617d5ea.png)

* 	**Microsoft Visual Studio Setup**  
1. Open Project Properties

2. Configuration: All Configurations, Platform: Win32

3. C/C++ -> General -> Additional Include Directories -> **$(SolutionDir)Dependencies\GLFW\include**

4. Linker -> Input -> Addtional Dependicies -> add "glfw3.lib" into the blank

5. Linker -> General -> Additional Library Directories -> $(SolutionDir)Dependencies\GLFW\lib-vc2015

   note that:  my **$(SolutionDir)** is located at D:\c++ files\HelloWorld\  

> static linking means library actually gets basically put into your excutable so it's just inside your .exe file or whatever your executable is for your operating system.
>
> a dynamic library gets linked at runtime so you still do have some kind of linkage you can choose to load a dynamic library. literally, there is a function called load library which you can use in the Windows API as an example and that will load you like your dynamic library and you can pull function pointers out of that. 
>
> glfw3.dll is the runtime kind of dynamic link library that we actually use if we are linking dynamically at runtime
>
> glfw3dll.lib is actually kind of the static library that we use with the dll. This file actually contains all of the locations of the functions and symbols inside glfw3.dll so that we can link against them at compile time 
>
> glfw3.lib is the static library, we do not need glfw3.dll file to be without exe file at runtime 

- [C++ Copy Constructor](https://blog.csdn.net/fox64194167/article/details/21174575)  
> 浅拷贝：两个变量进行浅拷贝时，它们指向同一个地址，它们的值相同。这样会有问题，当其中的一个析构了那个地址，另外一个也没有了，有时候会发生错误，但浅拷贝比较廉价。
>
> 深拷贝：两个变量进行深拷贝时，第二变量会重新申请一块区域来存放跟第一个变量指向地址的值。两个东西完全是独立的，只是值相同。消耗比较大，因为要重新申请空间。  

- [Shallow and Deep Copy in C++](https://youtu.be/C_nLA3hfw8E)  
> https://youtu.be/C_nLA3hfw8E  

  This is an illustration of how deep copy works I cropped from the video and stitched. The video link is provided above with hyper link. It really  helps me a lot.   

  ![](https://i.loli.net/2018/12/27/5c2444ace9b07.jpg)

- [C++ Notes: Shallow vs Deep Copies](http://www.fredosaurus.com/notes-cpp/oop-condestructors/shallowdeepcopy.html)  
> A *shallow copy* of an object copies all of the member field values. This works well if the fields are values, but may not be what you want for fields that point to dynamically allocated memory. The pointer will be copied. but the memory it points to will not be copied -- the field in both the original object and the copy will then point to the same dynamically allocated memory, which is not usually what you want. The default copy constructor and assignment operator make shallow copies.
>
> A *deep copy* copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. To make a deep copy, you must write a copy constructor and overload the assignment operator, otherwise the copy will point to the original, with disasterous consequences.

- [std::vector::capacity](http://www.cplusplus.com/reference/vector/vector/capacity/)  
> `size_type capacity() const noexcept;`
>
> **Return size of allocated storage capacity**
>
> Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.
>
> *This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion.*
>
> Notice that this *capacity* does not suppose a limit on the size of the vector. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size of a vector is given by member max_size.
>
> The *capacity* of a vector can be explicitly altered by calling member `vector::reserve`.

***
### 2018-12-26  
* [STL](https://www.geeksforgeeks.org/the-c-standard-template-library-stl/)  
> The Standard Template Library (STL) is a set of C++ template classes to provide common programming data structures and functions such as **lists, stacks, arrays, etc**. It is a library of container classes, algorithms and iterators. It is a generalized library and so, its components are parameterized. A working knowledge of template classes is a prerequisite  for working with STL.  

![](https://i.loli.net/2018/12/26/5c2338938d60d.png)  
> 1. The **Standard Template Library** (STL) is a set of C++ template classes to provide common programming data structures and functions such as lists, stacks, arrays, etc. It is a library of container classes, algorithms and iterators. It is a generalized library and so, its components are parameterized. A working knowledge of template classes is a prerequisite  for working with STL.  
> 2. The header **algorithm** defines a collection of functions especially designed to be used on ranges of elements. They act on containers and provide means for various operations  for the contents of the containers.
> 3. **Containers** or container classes store objects and data. There are in total seven standard “first-class” container classes  and three container adaptor classes and only seven header files that provide access to these containers or container adaptors.
> 4. The STL includes classes that overload the **function** call operator. Instances of such classes are called function objects or functors. Functors allow the working of the associated function to be customized with the help of parameters to be passed.
> 5. As the name suggests, **iterators** are used for working upon a sequence of values. They are the major feature that allow generality in STL.  

* [Iterators](https://www.geeksforgeeks.org/iterators-c-stl/)  
> Iterators are used to point at the memory addresses of STL containers. They are primarily used in sequence of numbers, characters etc. They reduce the complexity and execution time of program.  
> Operations of iterators :-
>
> 1. `begin() `:- This function is used to return the beginning position of the container.
> 2. `end() `:- This function is used to return the after end position of the container.
> 3. `advance() `:- This function is used to increment the iterator position till the specified number mentioned in its arguments.
> 4. `next()` :- This function returns the new iterator that the iterator would point after advancing the positions mentioned in its arguments.
> 5. `prev()` :- This function returns the new iterator that the iterator would point after decrementing the positions mentioned in its arguments.
> 6. `inserter() `:- This function is used to insert the elements at any position in the container. It accepts 2 arguments, the container and iterator to position where the elements have to be inserted.  

#### vector optimization  
```c++
#include<iostream>
#include<string>
#include<vector>

struct Vertex
{
	float x, y, z;

	Vertex(float x, float y, float z)
		: x(x), y(y), z(z)
	{
	}

	Vertex(const Vertex& vertex)
		: x(vertex.x), y(vertex.y), z(vertex.z)
	{
		std::cout << "Copied!" << std::endl;
	}
};

int main()
{
	std::vector<Vertex> vertices;
	//std::vector<Vertex> vertices(3); // it's gonna to construct three vertex objects

	vertices.reserve(3); // reserve makes sure that we have enough memory 
	// it prints 6 copies to console. 
	/*vertices.push_back(Vertex(1, 2, 3 )); // construct it in the current stack frame of the main function and put it into that vector
	vertices.push_back(Vertex(4, 5, 6)); 
	vertices.push_back(Vertex(7, 8, 9));*/

	vertices.emplace_back(1, 2, 3); 
	vertices.emplace_back(4, 5, 6);
	vertices.emplace_back(7, 8, 9);

	std::cin.get();
}
```

> optimization 1: construct that vertex in place in the actual memory that the vector actually allocated for us
>
> `emplace_back`: pass the parameter list for the constructor. hey, construct a vertex object with the following parameters in place in our actual memory
>
> optimization 2: if you know how many elements you need to add, you can predefine enough size to contain them
>
> `reserve`

- Here is a detailed and easy-understood explanation of [vector copy constructor](http://www-h.eng.cam.ac.uk/help/tpl/languages/C++/morevectormemory.html).  

- [Ways to copy a vector in C++](https://www.geeksforgeeks.org/ways-copy-vector-c/)  

***
### 2018-12-25  
#### smart pointers  
> you cannot copy **unique pointer** because it's unique.
>
> **shared pointer** has to allocate another block of memory called the control block where it stores that **reference count** and if you first create a new entity and then pass it into the **shared pointer** constructor it has to allocate that's two allocation 
>
> when you assign a **shared pointer** to another **shared pointer** thus copying it it will increase the ref count but when you assign a **shared pointer** to a **weak pointer**, it won't increase the ref count  

* `weak pointer`  
```c++
int main()
{
	{
		std::weak_ptr<Entity> e0;
		{
			std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
			e0 = sharedEntity;
		}  // e0 is freed here
	}
```

* `shared pointer`  
```c++
int main()
	{
		std::shared_ptr<Entity> e0;
		{
			std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
			e0 = sharedEntity;
		} // e0 still holds the reference to the entity
	}  // here, memeory is freed because it passes two scopes*/
```

* `unique pointer`  
```c++
int main()
{
		{
			//std::unique_ptr<Entity> entity(new Entity());
			std::unique_ptr<Entity> entity = std::make_unique<Entity>();
			std::unique_ptr<Entity> e0 = entity;  // wrong, because you cannot copy unique pointer
		} 
} 
```

1. `<Entity>` is the template argument
2. entity is the `unique pointer` name, then we have option to call constructor
3. `unique pointer` is defined explicitly

#### copying and copy constructor  
> what we need is deep copy, copy the entire object
>
> copy constructor is a constructor that gets called for that second string when you actually copy it
>
> when you assign a string to an object that is also a string when you try to create a new variable and you assign it with another variable which has the same type as a variable that you're actually creating you're copying that variable and thus you're calling something called the `copy constructor`
```c++
#include<iostream>
#include<string>

struct Vector2
{
	float x, y;
}; 

class String // string is made up of an array of characters
{
private:
	char* m_Buffer; // point to the buffer of chars
	unsigned int m_Size; // keep track of how big the string is
public:
	String(const char* string) // constructor
	{
		m_Size = strlen(string); // calculate how long the string is, so that we can copy the data from the string into the buffer
		m_Buffer = new char[m_Size + 1]; // decide how big of the buffer is
		memcpy(m_Buffer, string, m_Size);
		m_Buffer[m_Size] = 0;
	}

	String(const String& other) // copy constructor
		: m_Size(other.m_Size) // it's just an integer, so shallow copy is okay
	{
		std::cout << "Copied String!" << std::endl;

		m_Buffer = new char[m_Size + 1];
		memcpy(m_Buffer, other.m_Buffer, m_Size + 1);
	}
	/*	: m_Buffer(other.m_Buffer), m_Size(other.m_Size)  // default copy constructor
	{
	}*/

	// or use another way to define copy constructor
	/*String(const String& other)
	{
		memcpy(this, &other, sizeof(String));
	}
	*/

	~String() // destructor
	{
		delete[] m_Buffer;
	}

	char& operator[](unsigned int index)  // operator overload
	{
		return m_Buffer[index];
	}

	friend std::ostream& operator<<(std::ostream& stream, const String& string);
};

std::ostream& operator<<(std::ostream& stream, const String& string)
{
	stream << string.m_Buffer;
	return stream;
}

// if reference is not used, we get three string copies happening
// anchor3, anchor4, anchor5 totally three times copying
// what's actually happening is every time we copy a string we allocate memory on the heap, copy all that memory and then at the end of it, we free it. That's completely unnecessary.
void PrintString(const String& string)  // anchor2 
{
	std::cout << string << std::endl;
}

int main()
{
	/*int a = 2;
	int b = a;
	b = 3;  // a remains 2
	*/
	
	/*Vector2 a = { 2, 3 };
	Vector2 b = a;
	b.x = 5;  // a, b are two separate Vector2s 
	*/

	/*Vector2* a = new Vector2();
	Vector2* b = a; // actually copy the pointer
	b->x = 2;  // a and b are both pointing to the same memory address
	*/

	String string = "Cherno"; // m_Buffer = 0x00a517d0
	String second = string;  // anchor3, shallow cpoy a string, m_Buffer = 0x00a517d0
	// these two char pointers point to the same address

	second[2] = 'a';

	PrintString(string);  // anchor4
	PrintString(second);  // anchor5

	/*std::cout << string << std::endl;
	std::cout << second << std::endl;
	*/

	std::cin.get();
} // anchor 1, when the code run to anchor1, it tries to delete the buffer twice so we are trying to free the same block of memory twice. that's why we get a crash because the memory has already been freed it's not ours, we can not free it again
```
1. `strcpy` includes the null termination character
2. keep in mind that always pass your objects by const reference `const&`
3. In this code, a string class is created, which includes two members: `char pointe`r and `int`.
4. In user-defined string class, `constructor`, `destructor`, `copy constructor`, `operator overloading` and a `friend` declaration are developed.
5. `friend` declaration is a new feature for me, the detailed knowledge can be found [here](https://en.cppreference.com/w/cpp/language/friend).   
> The `friend` declaration appears in a *class body* and **grants a function or another class access to private and protected members of the class** where the friend declaration appears.  

#### array operator  

- [What does `->` mean in C++?](https://stackoverflow.com/questions/4113365/what-does-mean-in-c)  

> It's to access a **member function** or **member variable** of an object through a *pointer*, as opposed to a regular variable or reference.
>
> For example: with a regular variable or reference, you use the `.` operator to access member functions or member variables.
>
> ```c++
> std::string s = "abc";
> std::cout << s.length() << std::endl;
> ```
>
> But if you're working with a pointer, you need to use the `->` operator:
>
> ```c++
> std::string* s = new std::string("abc");
> std::cout << s->length() << std::endl;
> ```
>
> It can also be overloaded to perform a specific function for a certain object type. Smart pointers like `shared_ptr` and `unique_ptr`, as well as STL container iterators, overload this operator to mimic native pointer semantics.
>
> For example:
>
> ```c++
> std::map<int, int>::iterator it = mymap.begin(), end = mymap.end();
> for (; it != end; ++it)
>     std::cout << it->first << std::endl;
> ```
>
> `a->b` means `(*a).b`.
>
> If `a` is a *pointer*, `a->b` is the member `b` of which `a` points to.  

* get the offset of a certain member variable in memory  
```c++
struct Vector3
{
	float x, y, z;
};

int main() // entry point
{
	int offset = (int)&((Vector3*)nullptr)->z;
	std::cout << offset << std::endl;
	
	std::cin.get();
}
```

`int offset = (int)&((Vector3*)nullptr)->z;` 

1. first, we cast a `nullptr` to `Vector3*` type
2. use `->` to point to the class member
3. use `&` to obtain the address of variable in the memory
4. use `int` to cast it into integer type  

#### dynamic arrays  
> It's called a vector because Alex Stepanov, the designer of the Standard Template Library, was looking for a name to distinguish it from built-in arrays. He admits now that he made a mistake, because mathematics already uses the term 'vector' for a fixed-length sequence of numbers. Now C++0X will compound this mistake by introducing a class 'array' that will behave similar to a mathematical vector.
>
> Alex's lesson: be very careful every time you name something.
>
> https://stackoverflow.com/questions/581426/why-is-a-c-vector-called-a-vector  

> vector belongs to std namespace
>
> in fact, it shouldn't be called vector, it should be called something like arraylist
>
> vector can actually resize, thus it is truely called dynamic array
>
> all u need to do is allocate a vector, such as 10 elements, when you wanna extend it much bigger, then it will create a new array, copy the old one and paste it to the new one, finally, automatically delete the old one.

- [std::vector](https://en.cppreference.com/w/cpp/container/vector)
- [std::vector::erase](http://www.cplusplus.com/reference/vector/vector/erase/)

***
### 2018-12-24  
#### Operators and operator overloading  
> operators are just functions 

```c++
#include<iostream>
#include<string>

struct Vector2  // public is default
{
	float x, y;
	
	Vector2(float x, float y)
		: x(x), y(y) {}		

	Vector2 Add(const Vector2& other) const  // not modify class members
	{
		return Vector2(x + other.x, y + other.y); // other means struct parameters (x, y), use point to specify the point it refers to
	}

	Vector2 operator+(const Vector2& other) const
	{
		return Add(other);
	}

	Vector2 Multiply(const Vector2& other) const  
	{
		return Vector2(x * other.x, y * other.y); 
	}

	Vector2 operator*(const Vector2& other) const
	{
		return Multiply(other);
	}

	bool operator==(const Vector2& other) const
	{
		return x == other.x && y == other.y;
	}

	bool operator!=(const Vector2& other) const
	{
		//return !operator==(other);
		return !(*this == other);
	}
};

std::ostream& operator<<(std::ostream& stream, const Vector2& other)
{
	stream << other.x << ", " << other.y; 
	return stream; 
}

int main()
{
	Vector2 position(4.0f, 4.0f);
	Vector2 speed(0.5f, 1.5f);
	Vector2 powerup(1.1f, 1.1f);

	Vector2 result1 = position.Add(speed.Multiply(powerup));
	Vector2 result2 = position + speed * powerup;

	std::cout << result1 << std::endl;  
	std::cout << result2 << std::endl;  

	if (result1 == result2)
	{

	}

	std::cin.get();
}
```
* print class-inner content to the console   
```c++
std::ostream& operator<<(std::ostream& stream, const Vector2& other)
{
	stream << other.x << ", " << other.y; 
	return stream; 
}
```

1. use c++ `overload` feature  
2. `std::ostream` is the original definition of `<<`  
3. `operator<<` to indicate it's gonna use to overfload operator  
4. `std::ostream& stream` is the left side of `<<`  
5. `const Vector2& other` is the right side of `<<` needed to be print out 

* Error: no operator "<<" matches these operands  
```c++
std::cout << result1 << std::endl; 
std::cout << result2 << std::endl;  
```

1. left side of `<<` is a class `cout`  
2. right side of `<<` is various data types that `cout` already knows how to print out  
3. operand types are `std::ostream << Vector2`  
4. we can't do this because there is no `overload` for this operator which takes in an output stream which is what `cout` is and then an actual `Vector2` but we can add that  

Besides, here is a detailed explanation of [C++ Overloading (Operator and Function)](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)  
> C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively.

> An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation).

> When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.  

> **Function Overloading**  

> You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.  
>
> **Operators Overloading**  
>
> You can redefine or overload most of the built-in operators available in C++. Thus, a programmer can use operators with user-defined types as well.
>
> Overloaded operators are functions with special names: the keyword "operator" followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type and a parameter list.
>
> ```c++
> Box operator+(const Box&);
> ```
>
> declares the addition operator that can be used to **add** two Box objects and returns final Box object. Most overloaded operators may be defined as ordinary non-member functions or as class member functions. In case we define above function as non-member function of a class then we would have to pass two arguments for each operand as follows : 
>
> ```c++
> Box operator+(const Box&, const Box&);
> ```

#### this  
- Video  
> `this` is only accessible to us through a `member function`, `member function` meaning a function that belongs to a `class` so a `method` and inside a `method` we can reference `this` and what `this` is is a `pointer` to the current `object instance` that the `method` belongs to
> 
> we first need to `instantiate` an `object` and then call the `method` so the `method` has to be called with a valid `object` and the `this` keyword is a `pointer` to that object   
```c++
class Entity
{
public:
	int x, y;

	Entity(int x, int y)
	{
		this->x = x;
		this->y = y;
	}

	int GetX() const  // we are not allowed to modify the class
	{
		const Entity* e = this;  // so this has to be const type
		return x;
	}
};

int  main()
{
	Entity e;
	std::cin.get();
}
```

- [C++ this Pointer](https://www.tutorialspoint.com/cplusplus/cpp_this_pointer.htm)  

> Every object in C++ has access to its own address through an important pointer called **this** pointer. The **this** pointer is an implicit parameter to all member functions. Therefore, inside a member function, **this** may be used to refer to the invoking object.

> Friend functions do not have a **this** pointer, because friends are not members of a class. Only member functions have a **this** pointer.

- [References](https://isocpp.org/wiki/faq/references)  
> **Why does C++ have both pointers and references? ** 
>
> C++ inherited pointers from C, so they couldn’t be removed without causing serious compatibility problems. References are useful for several things, but the direct reason they were introduced in C++ was to support operator overloading. For example:
>
> ```c++
>     void f1(const complex* x, const complex* y) // without references
>     {
>         complex z = *x+*y;  // ugly
>         // ...
>     }
>     void f2(const complex& x, const complex& y) // with references
>     {
>         complex z = x+y;    // better
>         // ...
>     }   
> ```
>
> **When should I use references, and when should I use pointers?**
>
> Use references when you can, and pointers when you have to.
>
> **Should I use call-by-value or call-by-reference?**
>
> That depends on what you are trying to achieve:
>
> - If you want to **change the object passed**, call by reference or use a pointer;   
>
>   e.g., `void f(X&);`or `void f(X*);`.
>
> - If you don’t want to **change the object passed and it is big**, call by const reference; 
>
>   e.g., `void f(const X&);`.
>
> - **Otherwise**, call by value; 
>
>   e.g. `void f(X);`.
>
> *What does “big” mean?* Anything larger than a couple of words.

- [Use of the & operator in C++ function signatures](https://stackoverflow.com/questions/6877052/use-of-the-operator-in-c-function-signatures)  
> The `&` character in C++ is dual purpose. It can mean (at least)
> 1. Take the address of a value
> 2. Declare a reference to a type
> 
> The use you're referring to in the function signature is an instance of #2. The parameter `string& str` is a reference to a `string` instance. This is not just limited to function signatures, it can occur in method bodies as well.  

#### object lifetime  
In this video, two kinds of *object lifetime* are introduced, they are **stack lifetime** and **scope lifetime**.  
* stack lifetime  
```c++
#include<iostream>
#include<string>

class Entity
{
public:
	Entity()
	{
		std::cout << "Created Entity!" << std::endl;
	}

	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}
};

int* CreateArray()
{
	int array[50];  // declare it on the stack
	return array; // it returns a pointer to that stack memory, the stack memory gets cleared as soon as we go out of scope
}

int main()
{
	int* a = CreateArray();
	{
		Entity* e = new Entity(); // set breakpoint, even run pass anchor1 to anchor2
	} // anchor1

	std::cin.get();  // anchor2
}
```

1. the stack-based variable gets destroyed as soon as we go out of the scope
2. it is a mistake that people will create a stack-based variable and try to return a pointer to it, not realizing that once that function ends and you go out of scope that variables done

* scope lifetime  
```c++
#include<iostream>
#include<string>

class Entity
{
public:
	Entity()
	{
		std::cout << "Created Entity!" << std::endl;
	}

	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}
};

class ScopedPtr
{
private:
	Entity* m_Ptr;
public:
	ScopedPtr(Entity* ptr)
		: m_Ptr(ptr)
	{
	}

	~ScopedPtr()
	{
		delete m_Ptr;
	}
};

int main()
{
	{
		ScopedPtr e = new Entity();
	} 
	std::cin.get(); 
}
```

the scoped pointer class itself the scoped pointer object gets allocated on the stack which means it gets deleted and when it gets deleted automatically equals delete in the destructor which deletes that pointer `m_Ptr` that it's wrapping  

Some good references can be found as follows:  
- [C++ Classes and Objects](https://www.geeksforgeeks.org/c-classes-and-objects/)  
- [Object](https://en.cppreference.com/w/cpp/language/object)  
- [Object (computer science)](https://en.wikipedia.org/wiki/Object_(computer_science))  
- [Lifetime](https://en.cppreference.com/w/cpp/language/lifetime)  
- [What is the lifecycle of a C++ object?](https://stackoverflow.com/questions/17121305/what-is-the-lifecycle-of-a-c-object)  

> > 1) What are all the ways to create a C++ object?
>
> Same as C: they can be global variables, local automatic, local static or dynamic. You may be confused by the constructor, but simply think that every time you create an object, a constructor is called. Always. Which constructor is simply a matter of what parameters are used when creating the object.
>
> Assignment does not create a new object, it simply copies from one oject to another, (think of `memcpy` but smarter).
>
> > 2) What are all the different initialization syntaxes associated with all these types of object creation? What's the difference between T f = x, T f(x);, T f{x};, etc.?
>
> - `T f(x)` is the classic way, it simply creates an object of type `T` using the constructor that takes `x` as argument.
> - `T f{x}` is the new C++11 unified syntax, as it can be used to initialize aggregate types (arrays and such), but other than that it is equivalent to the former.
> - `T f = x` it depends on whether `x` is of type `T`. If it is, then it equivalent to the former, but if it is of different type, then it is equivalent to `T f = T(x)`. Not that it really matters, because the compiler is allowed to optimize away the extra copy (copy elision).
> - `T(x)`. You forgot this one. A temporary object of type `T` is created (using the same constructor as above), it is used whereever it happens in the code, and *at the end of the current full expression*, it is destroyed.
> - `T f`. This creates a value of type `T` using the default constructor, if available. That is simply a constructor that takes no parameters.
> - `T f{}`. Default contructed, but with the new unified syntax. Note that `T f()` is not an object of type `T`, but instead a function returning `T`!.
> - `T()`. A temporary object using the default constructor.
>
> > 3) Most importantly, when is it correct to copy/assign/whatever = is in C++, and when do you want to use pointers?
>
> You can use the same as in C. Think of the copy/assignment as if it where a `memcpy`. You can also pass references around, but you also may wait a while until you feel comfortable with those. What you should do, is: do not use pointers as auxiliary local variables, use references instead.
>
> > 4) Finally, what are all these things like shared_ptr, weak_ptr, etc.?
>
> They are tools in your C++ tool belt. You will have to learn through experience and some mistakes...
>
> - `shared_ptr` use when the ownership of the object is shared.
> - `unique_ptr` use when the ownership of the object is unique and unambiguous.
> - `weak_ptr` used to break loops in trees of `shared_ptr`. They are *not* detected automatically.
> - `vector`. Don't forget this one! Use it to create dynamic arrays of anything.
>
> PS: You forgot to ask about **destructors**. IMO, destructors are what gives C++ its personality, so be sure to use a lot of them!

***
### 2018-12-23  
#### Create objects  
> we basically have two choices here and the difference between the choices is where the memory comes from which memory were actually going to be creating our object in
​        when we create an object in C++, it needs to occupy some memory even if we write a class that is completely empty, no class members or nothing like that it has to occupy at least one byte of memory
​         stack objects for example, their lifetime is actually controlled by the scope that they declared and as soon as that variable goes out of scope, that's it the memory is free because when that scope ends the stack pops and anything that scope frame in that stack frame that gets freed
​         once you allocated an object in that heap, it's up to you to determine when to free that block of memory

* create class  

```c++
  class Entity
  {
  private:
  String m_Name;
  public:
  Entity() 
	: m_Name("Unkown")  //constructor 
  	{
  	}
  Entity(const String& name) 
	: m_Name(name) 
  	{
  	}
  const String& GetName() const 
  	{ 
		return m_Name; 
  	}
  };
```

* objects created on the stack  

```c++
int main()
{
	Entity* e;
	{  // use curly brace to create a scope
		Entity entity("Cherno");
		e = &entity;  // when the code runs to the next line of anchor1, content of e is freed because of scope 
		std::cout << entity.GetName() << std::endl;
	}  // anchor1
	std::cin.get();
}
```

* objects created on the heap  

```c++
int main()
{
	Entity* e;
	{  // use curly brace to create a scope
		Entity* entity = new Entity("Cherno"); 
		e = entity; // when the code runs to the next line of anchor2, content of e is freed because of heap memory is freed
		std::cout << entity->GetName() << std::endl; 
	}  // anchor1
	
	std::cin.get();
	delete e; // anchor2
}
```

* `Entity* entity = new Entity("Cherno");` we allocate memory on the `heap`, call the `constructor` and this new `entity` actually returns an entity pointer it returns the location on the `heap` where this entity has actually been allocated  

* `std::cout << entity->GetName() << std::endl;` since `entity` is a `Entity pointer`, you should dereference first, `(*entity).GetName()`

#### new and delete  
> The main purpose of `new` is to allocate memory on the `heap` specially
> 
> The `new` expression attempts to **allocate storage** and then attempts to **construct and initialize** either a single unnamed object, or an unnamed array of objects in the allocated storage. The new-expression **returns a prvalue pointer** to the constructed object or, if an array of objects was constructed, a pointer to the initial element of the array. [link](https://en.cppreference.com/w/cpp/language/new)

```c++
int a = 2;
int* b = new int[50]; // remember new returns a pointer, 200bytes

Entity* e = new Entity(); // not only allocate the memory, but alse calls the constructor, kind of like (Entity*)malloc(sizeof(Entity) in C, but the latter one does not call the constructor
	 
delete e; // free() in C, but delete also calls the destructor
delete[] b; // when free the array memory created by new square brackets
std::cin.get();
```

#### implicit conversion and explicit  
* first case  
```c++
X x;
Y y(x) //explicit conversion
```
* second case  
```c++
X x;
Y y = x; //implicit conversion
```
> one uses a Y's constructor and one uses the assignment operator though.

> Nope. In the second case it's not an assignment, it's an initialization, the assignment operator (`operator=`) is never called; instead, a non-`explicit` one-parameter constructor (that accepts the type  X as a parameter) is called.

> The difference between initialization and assignment is important: in the first case, a new object is being created, and it starts its life with the value that it is being initialized with (hence why a constructor is called), while assignment happens when an object is assigned (~copied) to an object that already exists and already is in a definite state.

> Anyway, the two forms of initialization that you wrote differ in the fact that in the first case you are explicitly calling a constructor, and thus any constructor is acceptable; in the second case, you're calling a constructor implicitly, since you're not using the "classical" constructor syntax, but the initialization syntax.

> In this case, only one-parameter constructors not marked with `explicit` are acceptable. Such constructors are called by some people "converting" constructors, because they are involved in implicit conversions.

> As specified [in this other answer](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163), any constructor not marked as `explicit` can take part in an implicit conversion for e.g. converting an object passed to a function to the type expected by such function. Actually, you may say that it's what happens in your second example: you want to initialize (=create with a value copied from elsewhere) `y` with `x`, but `x` first has to be converted to type `Y`, which is done with the implicit constructor.

> This kind of implicit conversion is often desirable: think for example to a string class that has a converting (i.e. non-`explicit`) constructor from a `const char *`: any function that receives a `string` parameter can also be called with a "normal" C-string: because of the converting constructor the caller will use C-strings, the callee will receive its `string` object.

> Still, in some cases one-parameters constructors may not be appropriate for conversion: usually this happens when their only parameter is not conceptually "converted" to the type of the object being created, but it is just a parameter for the construction; think for example about a file stream object: probably it will have a constructor that accepts the name of the file to open, but it makes no sense to say that such string is "converted" to a stream that works on that file.

> You can also find some more complex scenarios where these implicit conversions can completely mess-up the behavior that the programmer expects from overload resolution; examples of this can be found in the answers below the one I linked above.

> More simply, it can also happen that some constructors may be very heavyweight, so the class designer may want to make sure that they are invoked explicitly. In these cases, the constructor is marked as `explicit`, so it can be used only when called "explicitly as a constructor" and doesn't take part in implicit conversions.

This link can be found [here](https://stackoverflow.com/questions/7099957/implicit-vs-explicit-conversion)

***
### 2018-12-22  
#### ternary operator  
In fact, it is *conditional assignment.*  
`eg.1`  

```c++
if (s_Level > 5)
		s_Speed = 10;
	else
		s_Speed = 5;
		
s_Speed = s_Level > 5 ? 10 : 5;
```

`eg.2`  

```c++
if (s_Level > 5)
	if (s_Level > 10)
		s_Speed = 15;
	else
		s_Speed = 10;
else 
	s_Speed = 5;

s_Speed = s_Level > 5 ? s_Level > 10 ? 15 : 10 : 5;
```

***
### 2018-12-21  
#### mutable  

> https://en.cppreference.com/w/cpp/keyword/mutable  

**There are two usages of `mutable`, they are:**  
* mutable type specifier

  its uage can be found in [Const](#const)

* lambda-declarator 
> **Constructs a closure: an unnamed function object capable of capturing variables in scope.**
>
> **Lambda capture**
> The captures is a comma-separated list of zero or more captures, optionally beginning with the *capture-default*. The only capture defaults are
> `&` (implicitly capture the used automatic variables by reference) and
> `= `(implicitly capture the used automatic variables by copy).

More references can be found [here](https://blog.csdn.net/u012209626/article/details/47864727)

#### constructor initializer list
> it's a way for us to initialize our class member functions in the Constructors

* First case
```c++
class Example
{
public:
	Example()
	{
		std::cout << "Created Entity!" << std::endl;
	}

	Example(int x)
	{
		std::cout << "Created Entity with " << x << "!" << std::endl;
	}
};

class Entity
{
private:
	std::string m_Name;
	Example m_Example;  
public:
	Entity()  // default constructor
	{
		m_Name = std::string("Unknown");
		m_Example = Example(8); 
	}


	Entity(const std::string& name)
	{
		m_Name = name;
	}
	const std::string& GetName() const { return m_Name; }
};

int main()
{
	Entity e0;
	std::cin.get();
}
```
* Output:  
```c++
Created Entity!
Created Entity with 8!
```

* Second case
```c++
class Example
{
public:
	Example()
	{
		std::cout << "Created Entity!" << std::endl;
	}

	Example(int x)
	{
		std::cout << "Created Entity with " << x << "!" << std::endl;
	}
};

class Entity
{
private:
	std::string m_Name;
	Example m_Example;  
public:
	Entity()  // default constructor
        : m_Example(Example(8))
	{
		m_Name = std::string("Unknown");
	}


	Entity(const std::string& name)
	{
		m_Name = name;
	}
	const std::string& GetName() const { return m_Name; }
};

int main()
{
	Entity e0;
	std::cin.get();
}
```
* Output:  
```c++
Created Entity with 8!
```
***

### 2018-12-20  
#### String_literals   

* string literals are a series of character in between two double quotes.  
* string literals are stored in a read-only section of memory.  
* There are two ways to extend your strings.   
1. `std::string name0 = std::string("Cherno") + "hello";  // use constructor`
2. `std::string name5 = "Cherno"s + "hello"; // s means an operator function`

* multiple line style  
```c++
const char* example = R"(line1
Line2
Line3)";  // R to achieve multiple lines
```
* String Class instantiations  
```c++
const char* name = "Cherno";  // one byte per character, utf-8
const wchar_t* name2 = L"Cherno";  // two bytes per character on Windows
const char16_t* name3 = u"Cherno"; // two bytes per character, utf-16
const char32_t* name4 = U"Cherno"; // 4 bytes per character, utf-32
```
* string length  
```c++
#include<stdlib.h>
std::cout << strlen(string_name) << std::endl;
```

#### Const
> `const` is like a promise (keep constant), you can break your promise  

> For people having trouble remembering the order in which `const` keyword is to be used, here's a quick tip.
You have to *read it backward*, like the compiler does. For instance :
`const int * A;` -> "A is a pointer to an int that is constant."
(or, depending on how you prefer to write it)
`int const* A;` -> "A is a pointer to a const int"
but both are the same as explained in the video.
`int * const A;` -> "A is a const pointer to an int."
`const int* const A;` -> "A is a const pointer to an int that is constant".﻿

```c++
	const int MAX_AGE = 90; // the compiler treat it as a read-only constant

	//1st case
	int* a = new int;  // a is a pointer to an int
	*a = 2; // change the content
	//a = &MAX_AGE; // ERROR: a value of type "const int *" cannot be assigned to an entity of type "int *"
	a = (int*)&MAX_AGE;  // change the memory it points to
	std::cout << *a << std::endl;

	//2nd case 
	const int* a1 = new int;  // a1 is a pointer to an int that is constant
	*a1 = 2; 	// cannot modify the content	
	a1 = (int*)&MAX_AGE; 
	std::cout << *a1 << std::endl;

	//3rd case, equivalent to 2nd case
	int const* a2 = new int;  // a2 is a pointer to a constant int
	*a2 = 2; 	// cannot modify the content	
	a2 = (int*)&MAX_AGE;
	std::cout << *a2 << std::endl;

	// brief summary, if variable name is right next to pointer symbol *, which indicates that the content cannot be modified.

	//4th case
	int* const a3 = new int;  // a3 is a constant pointer to an int
	*a3 = 2; 	
	a3 = (int*)&MAX_AGE;  // cannot reassign the actual pointer itself to point to something else
	std::cout << *a3 << std::endl;

	//5th case
	const int* const a4 = new int;  // a4 is a constant pointer to an int that is constant
	*a4 = 2;  // cannot modify the content
	a4 = (int*)&MAX_AGE;  // cannot reassign the actual pointer itself to point to something else
	std::cout << *a4 << std::endl;
```
**There are four usages of `const` introduced in videos***  

1. cannot modify the content  
`const int* a = new int;` = `int const* a = new int;`
2. cannot reassign it to point to something else  
`int* const a = new int;`  
3. cannot modify the content, either reassign it to sth else  
`const int* const a = new int`  
4. `const` after a class method  
```c++
// 3rd usage of const
class Entity
{
private:
	int m_X, m_Y;  //int *m_X, *m_Y;
	mutable int var; // with mutable you can change it
public:
	int GetX() const // const after a method, it only works in a class
		// it means you cannot modify class member variables (line 8)
		// it is just kind of read-only method, it's just gonna read data from the class
	{
		var = 2; // that's ok because var is mutable
		m_X = 2; // it's not gonna work
		return m_X;
	}

	void SetX(int x)
	{
		m_X = x;
	}
};
```
* attention to keyword `mutable`

***

### 2018-12-19    
#### Generate course list   

* using python framework, since it is convenient to use crawler
* software Regester to pre-process
* requests package to parser html
* re to handle content

```python
import requests
# from bs4 import BeautifulSoup
import re

r = requests.get(url)
# html = r.content
# soup = BeautifulSoup(html, 'html.parser')

html = r.text

pattern1 = '(?<=data-title\=).*?(?=data-set-video-id)'
pattern2 = '(?<=\").*?(?=\")'

result1 = re.findall('(?<=data-title\=).*?(?=data-video-id)',html)
print(result1)

file=open('D:/data.txt','w')
file.write(str(result1))
file.close()
```
***

### 2018-12-18  
#### Strings  

Some good references here:
> https://en.wikipedia.org/wiki/ASCII
>
> http://www.cplusplus.com/reference/string/string/

```
string is an array of characters, letters, numbers, symbols
string of text
char pointer

passing string to func,  void PrintString(const std::string& string)
this is a reference meaning that it wouldn't get copied and const means we're not to modify it here

strings are immutable in the sense that you can't just extend a string and make it bigger because this is a fixed alllocated block of memory if you wanna have a bigger string you need to perform a brand new allocation and delete the old string
```
***

### 2018-12-17  
#### Array  
Array is a bunch of variables, it stores data contiguously (row).   
We can watch memory by enter `&variable_name`  

```c++
class Entity
{
public:
	int* example = new int[5]; //&e, then copy the former 4 bytes addr, and conduct endian convertion

	Entity()
	{
		for (int i = 0; i < 5; i++)
			example[i] = 2;
	}
};
```

* created on the stack  
`int example[5];`

* created on the heap  
`int* another = new int[5];`

* delete array memory created by new  
`delete[] another;`

#### Visibility  
Here, visibility mainly aims for `class` or `struct`.  
The default mode for `class` is `private`, while `struct` is `public`. In fact, there are totally three modes: they are `public`, `private` and `protected`.  

```c++
public:  // all can access
private: // none can access
protected:  // iner class(class and its subclass can access)
```

#### Pure_virtual_func2  
* view class diagram to see the relationship between them
![](https://i.loli.net/2019/01/02/5c2cbe96b076b.png)

#### SRO  
SRO means **scope resolution operator**  
- [x] SRO1.cpp  
we can access a global variable  
```c++
int x; // Global x 

int main()
{
	int x = 10; // Local x 
	cout << "Value of global x is " << ::x;
	cout << "\nValue of local x is " << x;
	cin.get();
	return 0;
}
```
- [x] SRO2.cpp  
```c++
class A
{
public:
	// Only declaration 
	void fun();
};

// Definition outside class using :: 
void A::fun()
{
	cout << "fun() called";
}

int main()
{
	A a;
	a.fun();
	cin.get();
	return 0;
}
```
- [x] SRO3.cpp  
* :: can be used to access static, members when there is a local variable with same name   
```c++
class Test
{
	static int x;
public:
	static int y;
	// Local parameter 'a' hides class member 
	// 'a', but we can access it using :: 
	void func(int x)
	{
		// We can access class's static variable 
		// even if there is a local variable 
		cout << "Value of static x is " << Test::x;   //line 26

		cout << "\nValue of local x is " << x;  // line 32
	}
};

// In C++, static members must be explicitly defined 
// like this 
int Test::x = 1;
int Test::y = 2;

int main()
{
	Test obj;
	int x = 3;
	obj.func(x);

	cout << "\nTest::y = " << Test::y;  // line 27

	return 0;
}
```
- [x] SRO4.cpp  
* Use of scope resolution operator in multiple inheritance.   
```c++
class A
{
protected:
	int x;
public:
	A() { x = 10; }
};

class B
{
protected:
	int x;
public:
	B() { x = 20; }
};

class C : public A, public B
{
public:
	void fun()
	{
		cout << "A's x is " << A::x;
		cout << "\nB's x is " << B::x;
	}
};

int main()
{
	C c;
	c.fun();
	return 0;
}
```

#### Pure_virtual_func  
* indicate a pure virtual func, it has to be implemented in a subclass  
  `virtual std::string GetName() = 0; `

```c++
#include<iostream>
#include<string>

class Entity
{
public:
	virtual std::string GetName() = 0; 
};

class Player : public Entity
{
private:
	std::string m_Name;
public:
	Player(const std::string& name)  // constructor
		: m_Name(name) {}

	std::string GetName() override   //subclass implement pure virtual function.
	{
		return m_Name;
	}
};

void PrintName(Entity* entity)  // depend on type, here is Entity*
{
	std::cout << entity->GetName() << std::endl;
}

int main()
{
	// use new to ctreate and initialize object with dynamic storage duration
	Entity* e = new Player("");
	PrintName(e); // output Entity

	Player* p = new Player("Cherno");
	PrintName(p);  //output Entity

	std::cin.get();
}
```
####  Virtual_func  
* use virtual to not overwrite subclass method  
  `virtual std::string GetName()`

####  Inheritance  
* Player is not only a class type, but also an Entity type  
```c++
class Entity 
{}

class Player : public Entity
{}
```

***

### 2018-12-16  
####  Constructor  
```c++
// constructor and deconstructor
#include<iostream>

class Entity
{
public:
	float X, Y;
	//in fact, it has default initialization, but it would be better to manually initialize it.
	Entity()   // define a constructor to help initialize
	{
		X = 0.0f;
		Y = 0.0f;
		std::cout << "Created Entity!" << std::endl;
	}

	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}
    
	void Print()
	{
		std::cout << X << ", " << Y << std::endl;
	}

};

void Function()
{
	Entity e;
	e.Print();
	e.~Entity();
}

int main()
{
	Function();
	std::cin.get();
}
```
#### Log1  
This code is related to **Main11.cpp**, it defines an `enum` class. 
####  Enum  
* enum, just give names to certain values  
```c++
enum Example : char
{
	A = 5, B, C = 8  // default enum is 32-bit 
};

int main()
{
	Example value = B;
	if (value == 1) {}
	std::cin.get();
}
```

***

### 2018-12-15  
- [x] Main14.cpp  
local static  
- [x] Main13.cpp  
`static` for classes and structs  
- [x] Staticcpp.cpp
- [x] Main12.cpp
related to **Staticcpp.cpp**
- [x] Main11.cpp  
**error, warning and info class**  
- [x] Main10.cpp  
**class**

***

### 2018-12-14  
- [x] Main9.cpp  
`int& ref = a;`  
`reference` is an alias name of `a`, only one variable when compiling, that is `a`.  
- [x] Main7.cpp  
* `#define LOG(x) std::cout << x << std::endl;`  
* This code demonstrates how to watch memory in *Visual Studio* and endian problem.  
* `memset`  
`void * memset ( void * ptr, int value, size_t num );`  
**fill block of memory**, Sets the first *num* bytes of the block of memory pointed by *ptr* to the specified *value* (interpreted as an `unsigned char`).  
- [x] Main8.cpp  
* set breakpoint to identify the endian mode is big endian or not, this code validates our machine is based on little-endian  
```c++
int main()
{
	int a = 0x1234; // normally 12 is high byte
	char b = *(char *)&a;  //convert int to one byte char, that is, fetch low addr and put it into b as if condition
	if (b == 0x12)   // dec 52 -> hex 34
		return true;
	else
		return false;
	std::cin.get();
}
```

***

### 2018-12-13  
- [x] Main6.cpp  
`retrun` a value or terminate the execution of a func  
```c++
int main()
{
	for (int i = 0; i < 5; i++)
	{
		if ((i + 1) % 2 == 0) // if (i % 2 != 0)
			return 0;  // jump to int main() 2nd curly brace
		Log("Hello World!");
		std::cout << i << std::endl;
	}
	std::cin.get();
}
```
- [x] Main5.cpp  
* `break`, quit the current loop  
```c++
int main()
{
	for (int i = 0; i < 5; i++)
	{
		if ((i + 1) % 2 == 0) // if (i % 2 != 0)
			break; // if the first odd i appears, quit the whole loop
		Log("Hello World!");
		std::cout << i << std::endl;
	}
	std::cin.get();
}
```
- [x] Main4.cpp  
* `continue`, go to next loop condition  
```c++
int main()
{
	for (int i = 0; i < 5; i++)
	{
		if (i % 2) // if (i % 2 != 0)
			continue; // when i = 1,3, run continue and go to next loop that is, neglect Log() 
		Log("Hello World!");
		std::cout << i << std::endl;
	}
	std::cin.get();
}
```
- [x] Main3.cpp  
```c++
// while loop (just one condition)

#include<iostream>
#include"log.h"

int main()
{
	for (int i = 0; i < 5; i++)
	{
		Log("Hello World!");
	}

	Log("=========================="); //just to seperate

	int i = 0;
	while (i < 5)
	{
		Log("Hello World!");
		i++;
	}

	Log("=========================="); //just to seperate

	i = 0;  // not int i = 0; or it will reprt error
			// redefinition: multiple initialization
	do
	{
		Log("Hello World!");
		i++;
	} while (i < 5);

	std::cin.get();
}
```
- [x] Main2.cpp  
```c++
	int i = 0; //first declaration, since it only runs one time
	bool condition = true;
	for( ;condition; )
	{
		Log("Hello World!");
		i++;
		if (i > 4)
			condition = false;
	}
```
- [x] Main1.cpp
- [x] Log.cpp
- [x] Main.cpp
- [x] log.h  
* just place a declaration  
`void Log(const char* message);`
- [x] func1.cpp  
```c++
void MultiplyAndLog(int a, int b)
{
    int answer = a * b;
    cout << answer << endl;
}
```

***

### 2018-12-12  
- [x] variables.cpp  
* data types determine the output.  
```c++
    char a = 65;
    short b = 65;
    char A = 'A';
    short B = 'A';

    cout << a << endl; //A
    cout << b << endl; //65
    cout << A << endl; //A
    cout << B << endl; //65
```
- [x] size_range.cpp  
We can use `sizeof` to know how big a data type is. for example, `sizeof(int)`  
And in C++, `INT_MAX` and `INT_MIN` indicate the biggest and smallest int data. We can include `#include<limits.h>` to see the `int` range.
- [x] Mathforfunc.cpp
- [x] varia.cpp  
* multiple data types  
```c++
	float variable = 5.6f;  // type int has 4 bytes
	double var = 2.5;
	
	int a;
	int* star = nullptr;  //define a pointer
	int& moon = a;  // define a reference
```
- [x] Math.cpp
- [x] printsh.cpp  
```c++
#include <iostream>
using namespace std;
#include "log.h"

void InitLog()
{
	Log("Initialized Log");
}

void Log(const char* msg)
{
	std::cout << msg << std::endl;
}
```
- [x] endofbrace.h  
Here to demonstrate the usage of header file: just to copy and paste.  
- [x] hello.cpp
- [x] this_demo.cpp  
`this` is a pointer, and it allows us to have access to class member function via `->`.
- [x] func_with_multiple_paras.cpp  
```c++
int addnums(int x, int y) {
	int ans = x + y;
	return ans;
}

int main() {
	cout << "The sum of two intergers are: " << addnums(6, 8) << endl;
	system("pause");
	return 0;
}
```
- [x] func_with_para.cpp
- [x] func_test.cpp  
function declaration first, then define function.  
**declaration -> call -> definition**